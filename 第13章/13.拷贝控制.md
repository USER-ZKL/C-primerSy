1. 当我们定义一个类时，**必须**显式或隐式的指定此类的**拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符**
2. 拷贝构造和移动构造说明了当用另一个同类型对象初始化时的行为
3. 拷贝赋值和移动赋值说明了赋值时的行为
4. 析构函数说明了销毁此对象时的行为
5. 如果没有自己定义，则编译器会自动生成这些函数

# 13.1.1 拷贝构造函数

1. 拷贝构造函数的**第一个参数必须是自身类类型的引用**
2. 此参数可用为非const的，但**通常总是声明为const的**
3. 其他任何参数**都要有默认值**
4. 由于拷贝构造函数在很多情况下会被隐式使用，所以**不能是explicit的**

## 合成拷贝构造函数

1. 即使我们定义了其他构造函数，**只要没有定义拷贝构造，则编译器就会自动合成一个拷贝构造函数**
2. 有些类的合成拷贝构造会**阻止我们拷贝该类类型的对象**
3. 一般情况，合成拷贝构造会逐个拷贝给定对象中**非static类型的成员**
4. 对于类类型的成员使用**其拷贝构造函数进行拷贝**
5. 合成拷贝构造会**逐一拷贝数组中的元素**
6. 如果一个数组中的类型为类类型，则使用其**拷贝构造函数进行拷贝**

## 拷贝初始化

**如果一个类有移动构造函数**则拷贝初始化有时会使用移动构造函数而非拷贝构造函数完成

拷贝初试化不仅在使用=定义变量时会发生，**在下列情况也会发生**

1. 将一个对象作为实参传递给一个非引用类型的形参
2. 从一个返回类型为非引用类型的函数返回一个对象
3. 用花括号列表初始化一个数组中的元素或聚合类的成员

![image-20210801142614045](E:\学习笔记\c++primer\picture\image-20210801142614045.png)

## 参数和返回值

1. 在调用函数时，具有**非引用类型的参数要进行拷贝初始化**
2. **为什么拷贝构造函数的参数要是引用类型的？**

```c++
class A{
    A(A a);
}
```

类似上述代码的拷贝构造。使用值传递

```c++
A now = aa;
```

使用A类型的变量aa来初始化now。此时调用拷贝构造函数A（A a）。但是由于其参数是非引用类型的，需要调用传入参数的拷贝构造函数将其拷贝到形参中。传入参数是aa是A类型的，此时调用aa的拷贝构造函数，但aa也是A类型的，它的构造函数同样是值传递的，因此又要进行拷贝构造。因此造成无限循环。

## 拷贝初始化的限制--explicit

![image-20210801145211721](E:\学习笔记\c++primer\picture\image-20210801145211721.png)

## 编译器可用绕过拷贝构造函数

![image-20210801145435414](E:\学习笔记\c++primer\picture\image-20210801145435414.png)

**编译器会使用直接初始化函数进行构造**

# 13.1.2 拷贝赋值运算符

可以定义拷贝赋值运算符，来控制类进行赋值时的行为

## 重载赋值运算符

1. 重载运算符实际上是一个函数，其名字为operator后接想要重载的运算符
2. 赋值运算符通常返回一个**指向其左侧运算对象的引用**
3. 标准库通常要求保存在容器中的类型**要具有赋值运算符**,且返回的是左侧对象的引用

## 合成拷贝赋值运算符

1. 如果我们没有定义，则编译器会合成一个拷贝赋值运算符
2. 某些类的合成拷贝运算符可以用来阻止其进行赋值操作
3. 一般情况会逐个赋值其类中的成员，其赋值操作是通过这些成员的拷贝赋值运算符完成的
4. 返回左侧对象的引用



# 13.1.3 析构函数

1. 析构函数释放对象使用的资源，销毁其非static成员
2. 析构函数**没有返回值，没有参数**
3. 因此没有参数所以**不能发生重载，一个类只能有一个析构函数**

## 析构函数完成什么工作

1. 析构函数首先执行函数体，然后按**成员初始化的顺序逆序销毁成员**
2. 类类型成员会调用其析构函数进行销毁
3. 内置类型没有析构函数，所以什么也不做
4. **销毁指针时，不会delete其所指向的对象**
5. 智能指针是一个类，有析构函数，所以会自动销毁

## 合成析构函数

1. 同理，如果我们没有定义析构函数，编译器会自动合成析构函数
2. 某些类的析构函数会**阻止其对象被销毁**
3. 一般情况析构函数的函数体就为空

**析构函数本身并不销毁成员，成员是在析构函数的函数体执行完之后的析构阶段进行销毁的。在整个销毁过程中，析构函数是作为成员销毁步骤之外的一部分而进行的**

# 13.1.4 三/五法则

1. 需要虚构函数的类也需要拷贝和赋值操作，反之不一定

**如果一个类需要我们自定义析构函数，那么可以肯定这个类也需要进行拷贝控制**

如前几节写的类HasPtr

```c++
#include<string>
using string;
class HasPtr{
public:

	~HasPtr(){
		delete ps;	//默认析构操作不会释放指针所指向的对象 
	} 
private:
	string *ps;
	int i;
}; 
```

这个类有一个指针成员，我们需要在析构函数中将其指向的对象释放。

如果我们使用合成的默认拷贝构造函数。那么，这个拷贝构造会简单的将给定对象的指针成员进行拷贝。

则，两个对象的指针成员就有相同的值，指向同一块内存。

当析构时，会对该内存delete两次，造成未定义的行为。以及可能对已经delete的内存进行操作

2. **如果一个类需要拷贝构造函数则一定需要拷贝赋值运算符，反之亦然**
3. **需要拷贝控制操作的类不一定需要析构函数**

# 13.1.5 使用=default

1. 我们可以将拷贝控制成员定义为=default来显式要求编译器生成合成的函数
2. 在类内使用=default声明函数时，合成的函数将隐式声明为内联的
3. 如果不希望是内联的则，应该**只在类外定义处声明=default**

![image-20210801164609063](E:\学习笔记\c++primer\picture\image-20210801164609063.png)

4. 只能对具有合成版本的函数使用=default

# 13.1.6 阻止拷贝

对某些类来说拷贝操作不合理，例如iostream类，就阻止了拷贝，防止多个对象读取相同的IO缓冲。但如果我们不定义拷贝控制函数，则编译器会生成默认的。因此，应采取某种操作阻止拷贝

## 定义删除的函数

1. 可以在函数参数列表后加=delete，指出希望该函数是被删除的
2. =delete必须出现在第一次声明时
3. 可以对任何函数指定=delete

![image-20210801165250218](E:\学习笔记\c++primer\picture\image-20210801165250218.png)

## 析构函数不能是删除的

1. 如果一个类或该类的类成员的析构函数是被删除的，则编译器不允许创建该类的对象或临时变量
2. **虽然不能创建，但可以动态分配，但不能删除该对象**

![image-20210801165621601](E:\学习笔记\c++primer\picture\image-20210801165621601.png)

## 合成的成员函数可能是删除的

如果一个类不能被默认构造，拷贝，复制或销毁。则其合成的成员函数会被定义为删除的

# 13.2.1 行为像值的类

## 类值拷贝赋值运算符

1. 具有析构函数的功能，能够销毁左侧对象的资源
2. 具有构造函数的功能，从右侧对象拷贝数据

```c++
HasPtr& operator= (const HasPtr& h){
			auto *tmp = new string(*(h.ps));//防止自自身拷贝
			delete ps;	//释放ps原来指向的内存空间 
			ps = tmp;
			i = h.i; 
			return *this;
	} 
```

**为什么要先将右侧拷贝下来？**

因为，如果发生自己拷贝给自己的情况，delete语句会将自身资源消耗，造成无法赋值成功

![image-20210802114231435](E:\学习笔记\c++primer\picture\image-20210802114231435.png)

# 13.2.2 定义行为像指针的类

1. 由于行为类似指针，即多个对象共享同一数据
2. 因此，当消耗一个对象时，析构函数不能单方面将该块资源消耗
3. 比较简单的方法是使用智能指针
4. 我们可以自己使用引用计数来进行管理
5. 将计数器保存在动态内存中。创建一个对象就初始化一个计数器。当拷贝和赋值时会拷贝计数器的指针，这样两个对象就指向同一计数器，并将计数器加一

![image-20210802120033931](E:\学习笔记\c++primer\picture\image-20210802120033931.png)

## 拷贝构造成员修改计数器

1. 析构函数在销毁对象时将计数器减一，当计数器值为0时，将资源释放

   ![image-20210802120352938](E:\学习笔记\c++primer\picture\image-20210802120352938.png)

2. 拷贝赋值运算符将左侧对象计数器减1，将右侧对象计数器加1

3. 同样为了处理自赋值，应该**先递增右侧对象计数器，再递减左侧计数器**，否则，如果**先递减左侧计数器，此时一旦计数器值为0，则要销毁资源，就造成拷贝错误**

# 13.3 交换操作

1. 对于那些需要应用于重排元素顺序的算法的类，定义swap函数是很重要的
2. 如果我们不定义，则算法将使用标准库定义的swap

![image-20210802135241538](E:\学习笔记\c++primer\picture\image-20210802135241538.png)

对于上述中的swap操作，创建了一个临时对象temp，即开辟了一块额外的空间

但是**这块空间是不必要的，我们交换两个空间的指针即可**

![image-20210802135413638](E:\学习笔记\c++primer\picture\image-20210802135413638.png)

## 编写自己的swap函数

![image-20210802135446032](E:\学习笔记\c++primer\picture\image-20210802135446032.png)

**注意上述代码中的using std::swap**

该代码中调用swap,由于其参数为内置类型，没有自己的swap函数，则会调用标准库的swap

如果我们有一个类，其有一个成员为HasPtr类型的。

![image-20210802140407269](E:\学习笔记\c++primer\picture\image-20210802140407269.png)

上述这种写法调用标准库的swap函数，错误

![image-20210802140517566](E:\学习笔记\c++primer\picture\image-20210802140517566.png)

正确写法是这样。因此在编写swap函数时，要加上 using std::swap

其作用是**声明标准库的swap函数名，如果swap函数中给的参数没有自定义的swap函数那么就调用标准库函数，如果有自定义的swap函数那么就调用他自己的**

**疑问？ 为什么在该代码块中对标准库的swap声明不会隐藏HasPtr自己的swap版本呢？ 后续会介绍**

## 在赋值运算符中使用swap操作

![image-20210802141509401](E:\学习笔记\c++primer\picture\image-20210802141509401.png)

**注意上述函数的参数是值传递的**

1. 首先会将右侧对象的一份拷贝到形参rhs中
2. 之后会交换形参与左侧对象中的指针
3. 交换完毕后，左侧对象的指针指向右侧对象的一份拷贝
4. rhs的指针指向左侧对象原来的值
5. 当函数结束时会调用形参rhs的析构函数，将左侧对象原来的资源释放

**很巧妙，由于是值传递，会进行一次拷贝也能解决自赋值的问题**

# 13.4 拷贝控制示例

这一节定义两个类进行示例

一个message的消息类和一个folder的目录类。message只有一份实体，因此，folder中含有一个指向massage类型的指针set，记录该目录中的消息。每个消息可以放在多个目录中，因此每个message中也有一个指向folder的指针set

**message操作**

save和remove

创建一条消息时只记录数据，不指定其所在目录。使用save函数将其保存到指定目录中，需要在该消息的set中添加目录指针，且在目录类的set中添加该消息的指针

remove销毁一条消息，需要将其从目录中删除，即从目录的set中删除该消息的指针

拷贝构造操作

当拷贝一条构造消息时，同时也拷贝了其所在目录的set。需要在其所在的目录set中添加该消息的指针

拷贝赋值操作

需要将原来消息从其所在目录中删除，并将其添加到现在这条消息所在的目录中

销毁操作

将其从所在目录中删除

![image-20210802155021663](E:\学习笔记\c++primer\picture\image-20210802155021663.png)

